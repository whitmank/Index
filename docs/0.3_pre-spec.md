# Index v0.3 - Pre-Specification

> Working document for the v0.3 architecture overhaul.
> Status: DRAFT - subject to refinement

---

## 1. Conceptual Reframe

### 1.1 From Files to Objects

v0.2 was built around "files" as the core entity. v0.3 reframes this:

**v0.2 Mental Model:**
> "Index is a file manager with tags and graph visualization"

**v0.3 Mental Model:**
> "Index is an information manager for objects that point to sources"

An **object** (node) is anything with:
- A **name** (human-readable identifier)
- A **source** (URI pointing to the actual thing)
- **Metadata** (source-type-specific attributes)

### 1.2 Sources as URIs

Objects reference their source via standard URI schemes:

```
file:///Users/karter/documents/report.pdf
https://example.com/article/intro-to-graphs
notion://page/abc123
custom://any-scheme-you-want
```

This abstraction means:
- Files are just one type of source
- URLs, API resources, app-specific links all work the same way
- The tagging, collections, and graph systems are source-agnostic

### 1.3 v0.3 Scope

**Implement:** `file://` and `https://` sources
**Design for:** Extensible source handler architecture

---

## 2. Architecture

### 2.1 High-Level Structure

```
┌─────────────────────────────────────────────────────────────┐
│                      Electron Shell                          │
│  ┌──────────────────┐  ┌──────────────────────────────────┐ │
│  │   Main Process   │  │         Renderer (React)         │ │
│  │  - IPC Bridge    │  │  - State Store (Zustand/etc)     │ │
│  │  - Source IPC    │  │  - Source-aware UI components    │ │
│  └────────┬─────────┘  └───────────────┬──────────────────┘ │
└───────────┼────────────────────────────┼────────────────────┘
            │                            │
            ▼                            ▼
┌─────────────────────────────────────────────────────────────┐
│                       Core Services                          │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │  Database   │  │   Source    │  │   Source Handlers   │  │
│  │  (SurrealDB)│  │   Router    │  │  ┌───────────────┐  │  │
│  │             │  │             │  │  │ file://       │  │  │
│  │  - Objects  │  │  Dispatches │  │  │ - fs ops      │  │  │
│  │  - Tags     │  │  to handler │  │  │ - watching    │  │  │
│  │  - Links    │  │  by scheme  │  │  │ - hashing     │  │  │
│  │  - Colls    │  │             │  │  ├───────────────┤  │  │
│  │             │  │             │  │  │ https://      │  │  │
│  └─────────────┘  └─────────────┘  │  │ - fetch       │  │  │
│                                     │  │ - cache       │  │  │
│                                     │  │ - metadata    │  │  │
│                                     │  └───────────────┘  │  │
│                                     └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 Source Handler Interface

Each source type implements a handler:

```typescript
interface SourceHandler {
  scheme: string;                    // "file", "https", etc.

  // Validation
  canHandle(uri: string): boolean;
  validate(uri: string): ValidationResult;

  // Metadata extraction
  extractMetadata(uri: string): Promise<Metadata>;

  // Content operations
  getContent(uri: string): Promise<Content | null>;
  getContentHash(uri: string): Promise<string | null>;

  // Source-specific capabilities
  capabilities: {
    canWatch: boolean;              // file:// yes, https:// no
    canOpen: boolean;               // Launch in native app
    canPreview: boolean;            // Render inline
    canCache: boolean;              // Store local copy
  };

  // Optional operations
  watch?(uri: string): Watcher;
  open?(uri: string): void;
  cache?(uri: string): Promise<CachedContent>;
}
```

### 2.3 State Management

**v0.2 Problem:** All state lives in `Layout.jsx`

**v0.3 Solution:** Dedicated state store (evaluate Zustand, Jotai, or similar)

```
┌─────────────────────────────────────────┐
│              State Store                 │
├─────────────────────────────────────────┤
│  objects: Map<id, Object>               │
│  tags: Map<id, Tag>                     │
│  collections: Map<id, Collection>       │
│  links: Map<id, Link>                   │
│  selection: Set<id>                     │
│  ui: { sidebarOpen, detailPanel, ... }  │
├─────────────────────────────────────────┤
│  Actions:                               │
│  - loadObjects()                        │
│  - addObject(uri, metadata)             │
│  - tagObject(objectId, tagName)         │
│  - selectObjects(ids)                   │
│  - ...                                  │
└─────────────────────────────────────────┘
```

---

## 3. Data Model

### 3.1 Objects (formerly Nodes)

```javascript
{
  id: "objects:ulid",

  // Core identity
  name: "Report Q4",                       // Optional - auto-derived from source if not provided
  source: "file:///Users/karter/report.pdf", // URI to actual thing
  type: "file",                            // Denormalized source type (file, url, etc.)

  // Content fingerprint (optional, source-dependent)
  content_hash: "sha256:abc123...",        // For deduplication

  // Timestamps
  created_at: ISO8601,                     // When indexed
  modified_at: ISO8601,                    // Last update in Index
  source_modified_at: ISO8601,             // Last change at source

  // Source-extracted metadata (read-only)
  source_meta: {
    size: 73264,
    mime_type: "application/pdf",
    extension: ".pdf",                     // file:// specific
    // https:// might have: title, description, favicon
  },

  // User-defined metadata
  user_meta: {
    notes: "Quarterly report for stakeholders",
    // Any additional user-defined fields
  }
}
```

**Name Derivation:**
- `file://` → filename (e.g., `report.pdf`)
- `https://` → page `<title>` or URL path
- User can override at any time

### 3.2 Tags

Split into two entities for global tag management:

**TagDefinitions** (canonical tag registry)
```javascript
{
  id: "tag_definitions:ulid",
  name: "important",                       // Unique tag name
  color: "#FF5733",                        // Optional visual color
  description: "High priority items",      // Optional description
  created_at: ISO8601
}
```

**TagAssignments** (object-tag relationships)
```javascript
{
  id: "tag_assignments:ulid",
  tag_id: "tag_definitions:abc123",        // Reference to TagDefinition
  object_id: "objects:xyz789",             // Reference to Object
  created_at: ISO8601
}
```

**Benefits:**
- Rename a tag globally by updating TagDefinition
- Tag colors and descriptions in one place
- Query all objects with a tag via assignments

### 3.3 Collections

```javascript
{
  id: "collections:ulid",
  name: "Project Alpha",
  description: "Active files for Project Alpha", // Optional description

  // Query with full AND/OR/NOT logic
  query: {
    all: ["alpha", "active"],              // Must have ALL these tags (AND)
    any: ["urgent", "review"],             // Must have ANY of these tags (OR)
    none: ["archived", "deprecated"]       // Must NOT have these tags (NOT)
  },

  color: "#4D9FFF",                        // Visual identifier
  pinned: false,                           // Pinned to sidebar (in DB, not localStorage)
  created_at: ISO8601
}
```

**Query Logic:**
- `all`: Object must have every tag listed (AND)
- `any`: Object must have at least one tag listed (OR)
- `none`: Object must not have any tag listed (NOT)
- All three can be combined: `(all AND any) AND NOT none`

### 3.4 Links

```javascript
{
  id: "links:ulid",
  source_object: "objects:abc",
  target_object: "objects:xyz",
  type: "related",                         // Predefined type category
  label: "references",                     // User-provided description
  bidirectional: true,                     // If true, link visible from both objects
  created_at: ISO8601,
  metadata: {}
}
```

**Link Types** (predefined categories):
- `related` - General relationship
- `derivative` - Target derived from source
- `reference` - Source references target
- (extensible)

**Directionality:**
- `bidirectional: false` → A → B only (default)
- `bidirectional: true` → A ↔ B visible from both sides

---

## 4. Source Handlers (v0.3)

### 4.1 File Handler (`file://`)

**Capabilities:**
- Watch for changes: YES
- Open in native app: YES
- Preview inline: YES (images, text, PDF)
- Cache content: NO (already local)
- Content hash: YES (SHA-256)

**Metadata extracted:**
- size, mime_type, extension
- created_at, modified_at (from filesystem)
- permissions (optional)

**Operations:**
- `extractMetadata`: fs.stat + mime detection
- `getContentHash`: SHA-256 stream hash
- `watch`: chokidar file watcher
- `open`: shell.openPath (Electron)

### 4.2 URL Handler (`https://`)

**Capabilities:**
- Watch for changes: NO
- Open in browser: YES
- Preview inline: YES (with cache)
- Cache content: YES
- Content hash: YES (of cached content)

**Metadata extracted:**
- title (from `<title>` or Open Graph)
- description (meta description or OG)
- favicon
- mime_type (from Content-Type)
- size (from Content-Length or cached)

**Operations:**
- `extractMetadata`: HEAD request + HTML parse
- `getContent`: Fetch and cache
- `getContentHash`: Hash of cached content
- `open`: shell.openExternal (Electron)

---

## 5. UI Adaptations

### 5.1 Source-Aware Components

**DetailPanel:**
- Show source URI (clickable to open)
- Display source-specific metadata
- "Open" button behavior varies by source type
- Preview section adapts to content type

**FileListTable → ObjectListTable:**
- Rename to reflect object model
- Source column shows URI scheme icon + truncated path
- Type column shows mime_type or source category

**Import Flow:**
- "Add Files" button remains (file:// sources)
- "Add URL" button or input field (https:// sources)
- Paste detection: file paths OR URLs

### 5.2 Source Type Indicators

Visual indicators for source types:
- `file://` - folder/file icon
- `https://` - globe/link icon
- Future schemes get their own icons

---

## 6. Migration from v0.2

### 6.1 Data Migration

**Nodes → Objects:**
```javascript
// v0.2
{
  source_path: "/path/to/file.png",
  metadata: { size, mime_type, notes, ... },
  ...
}

// v0.3
{
  source: "file:///path/to/file.png",
  type: "file",
  source_meta: { size, mime_type, ... },
  user_meta: { notes, ... },
  ...
}
```

**Tags → TagDefinitions + TagAssignments:**
```javascript
// v0.2
{ id, name: "important", node_id: "nodes:abc" }

// v0.3
// TagDefinitions:
{ id: "tag_definitions:xyz", name: "important", color: null, description: null }
// TagAssignments:
{ id, tag_id: "tag_definitions:xyz", object_id: "objects:abc" }
```

**Collections:**
```javascript
// v0.2
{ tags: ["alpha", "active"], ... }

// v0.3
{
  query: { all: ["alpha", "active"], any: [], none: [] },
  description: null,
  pinned: false,
  ...
}
```

**Links:**
```javascript
// v0.2
{ strength: 0.8, ... }

// v0.3
{ label: null, bidirectional: false, ... }  // strength removed
```

**Migration script tasks:**
1. Convert `source_path` → `source` (prepend `file://`)
2. Add `type: "file"` to all existing objects
3. Split `metadata` into `source_meta` and `user_meta`
4. Extract unique tag names into TagDefinitions table
5. Convert tag records to TagAssignments with tag_id references
6. Convert collection `tags` array to `query.all` format
7. Add default values for new collection fields
8. Remove `strength` from links, add `bidirectional: false`

### 6.2 API Changes

| v0.2 | v0.3 |
|------|------|
| `/api/nodes` | `/api/objects` |
| `/api/nodes/:id` | `/api/objects/:id` |
| `/api/tags` | `/api/tags` (TagDefinitions) |
| `/api/tags` (create) | `/api/tags/assign` (TagAssignments) |
| `POST /api/index` | `POST /api/objects/import` |

### 6.3 Breaking Changes

- `source_path` field removed (now `source` with URI)
- `metadata` split into `source_meta` and `user_meta`
- Tags restructured: definitions + assignments
- Collection `tags` array replaced with `query` object
- Link `strength` removed
- Node IDs change format (`nodes:` → `objects:`)
- API endpoints renamed
- All state in database (no localStorage)

---

## 7. Implementation Phases

### Phase 1: Core Architecture
- [ ] Set up new project structure
- [ ] Implement state store (choose library)
- [ ] Define source handler interface
- [ ] Implement file:// handler (port from v0.2)
- [ ] Basic UI with object model

### Phase 2: URL Sources
- [ ] Implement https:// handler
- [ ] Metadata extraction (title, favicon, etc.)
- [ ] Content caching system
- [ ] URL import UI

### Phase 3: Feature Parity
- [ ] Tags system (TagDefinitions + TagAssignments)
- [ ] Collections system (AND/OR/NOT queries)
- [ ] Links system (bidirectional, labels)
- [ ] Graph visualization
- [ ] Multi-select and keyboard shortcuts

### Phase 4: Polish
- [ ] Migration script for v0.2 data
- [ ] Error handling and edge cases
- [ ] Performance optimization
- [ ] Documentation

---

## 8. Open Questions

1. ~~**Table naming:** Keep `nodes` for backwards compatibility or rename to `objects`?~~
   **RESOLVED:** Rename to `objects` to reflect the conceptual model.

2. **URL caching strategy:** Cache on import, on first view, or on demand?

3. **Offline handling:** What happens when https:// sources are unreachable?

4. **Deduplication across sources:** Same content at file:// and https:// - detect as duplicate?

5. **Graph visualization:** Keep D3 force sim or explore alternatives for scale?

6. **Tag definition colors:** How are colors assigned? User picks, auto-generated, or predefined palette?

7. **Collection query UI:** How do users build AND/OR/NOT queries? Visual builder or text-based?

---

## 9. Success Criteria for v0.3

- [ ] Can import and manage file:// sources (feature parity with v0.2)
- [ ] Can import and manage https:// sources (new capability)
- [ ] State management is cleanly separated from UI components
- [ ] Source handler architecture allows adding new schemes without core changes
- [ ] All v0.2 features work with the new object model
- [ ] Tags support global rename via TagDefinitions
- [ ] Collections support AND/OR/NOT query logic
- [ ] All application state persisted in database (no localStorage)

---

*Pre-spec drafted: January 2026*
*Data model revised: January 2026*
*Status: Ready for refinement*
